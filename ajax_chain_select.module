<?php

/**
 * @file
 * Custom form field for chained select controls.
 */

/**
 * Implements hook_menu().
 */
function ajax_chain_select_menu() {
  $items = array();

  $items['ajax_chain_select/callback'] = array(
    'page callback' => 'ajax_chain_select_element_callback',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_element_info().
 */
function ajax_chain_select_element_info() {
  $elements['ac_select'] = array(
    "#input" => TRUE,
    "#process" => array('ajax_chain_select_element_ac_select'),
  );
  return $elements;
}

/**
 * Process callback for ac_select.
 */
function ajax_chain_select_element_ac_select($element, &$form_state, $form) {
  drupal_add_js(drupal_get_path('module', 'ajax_chain_select') . '/ajax_chain_select.js');

  $element_name = $element['#name'];
  $config = !empty($element['#config']) ? $element['#config'] : array();
  $levels = !empty($element['#levels']) ? $element['#levels'] : 1;
  $required_levels = !empty($element['#required_levels']) ? $element['#required_levels'] : 0;
  $data_callback = !empty($element['#data_callback']) ? $element['#data_callback'] : '';

  if (!function_exists($data_callback)) {
    return array('#markup' => 'Data callback not defined');
  }

  // Checking if the form has been sumbitted or not.
  $is_submitted = (!empty($form_state['input']));
  $submitted_values = $form_state['values']['region'];

  $region_element = array(
    '#array_parents' => array(),
    '#tree' => FALSE,
  );

  $region_element[$element_name] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#title' => !empty($element['#title']) ? $element['#title'] : array(),
    '#array_parents' => array(),
    '#attributes' => array('class' => array('f3region-fieldset')),
    '#element_validate' => array('ajax_chain_select_custom_validate'),
    '#states' => !empty($element['#states']) ? $element['#states'] : array(),
    '#levels' => $levels,
    '#data_callback' => $data_callback,
  );

  for ($level = 0; $level < $levels; $level++) {

    $previous_level = $level - 1;
    $data = array();

    switch ($level) {
      case 0:
        $data = $data_callback($level);
        break;

      default:
        if ($is_submitted) {
          if (!empty($submitted_values['level_' . $previous_level])) {
            $data = $data_callback($level, $submitted_values['level_' . $previous_level]);
          }
        }
        else {
          if (!empty($config[$previous_level]['#default_value'])) {
            $data = $data_callback($level, $config[$previous_level]['#default_value']);
          }
        }
        break;
    }

    // Default value must be part of data of that level, if not, nullify it.
    if (!empty($config[$level]['#default_value']) && !in_array($config[$level]['#default_value'], array_keys($data))) {
      unset($config[$level]['#default_value']);
    }

    $region_element[$element_name]['level_' . $level] = array(
      '#type' => 'select',
      '#options' => $data,
      '#title' => !empty($config[$level]['#title']) ? $config[$level]['#title'] : 'Level ' . ($level + 1),
      '#empty_option' => !empty($config[$level]['#empty_option']) ? $config[$level]['#empty_option'] : '- Select -',
      '#required' => ($level < $required_levels) ? TRUE : FALSE,
      '#validated' => TRUE,
      '#default_value' => !empty($config[$level]['#default_value']) ? $config[$level]['#default_value'] : NULL,
      '#title_display' => !empty($config[$level]['#title_display']) ? $config[$level]['#title_display'] : 'before',
      '#disabled' => (empty($data)) ? TRUE : FALSE,
    );

    if ($level != $levels - 1) {
      /* Instead of AHAH, we are using direct call to data function,
       * this makes the call much lighter and faster as compared to AHAH,
       * that submits the complete form data. */
      $region_element[$element_name]['level_' . $level]['#attributes']['onchange'] = "f3region_get_element(this, $level)";
      $region_element[$element_name]['level_' . $level]['#attributes']['class'] = array('ajax-chain-select-select');
    }
  }

  $region_element[$element_name]['dc'] = array(
    '#type' => 'textfield',
    '#value' => base64_encode($element['#data_callback']),
    '#attributes' => array('hidden' => TRUE, 'class' => array('acs-dc')),
  );

  $region_element[$element_name]['dch'] = array(
    '#type' => 'textfield',
    '#value' => ajax_chain_select_get_token($element['#data_callback']),
    '#attributes' => array('hidden' => TRUE, 'class' => array('acs-dch')),
  );

  return $region_element;
}

/**
 * Custom function for ac_select element validate.
 */
function ajax_chain_select_custom_validate(&$element, &$form_state, $form) {
  $values = $form_state['values'];
  $data_callback = $element['#data_callback'];
  $levels = $element['#levels'];

  for ($level = 0; $level < $levels; $level++) {

    $previous_level = $level - 1;

    if ($level > 0) {
      $data = $data_callback($level, $values['region']['level_' . $previous_level]);

      if (!empty($data)) {

        if (empty($element['level_' . $level]['#options'])) {
          $element['level_' . $level]['#options'] = $data;
        }
        $element['level_' . $level]['#validated'] = FALSE;
        _form_validate($element['level_' . $level], $form_state);
      }
    }
    else {
      $element['level_' . $level]['#validated'] = FALSE;
      _form_validate($element['level_' . $level], $form_state);
    }
  }
}

/**
 * Callback function for fetching data for next step of ac_select.
 */
function ajax_chain_select_element_callback($level = 1, $previous_level_key = 0, $dc = NULL, $dch = NULL) {
  $has_data = 0;
  $data_callback = '';
  $options = array();

  if (!empty($dc)) {
    $dc2 = base64_decode($dc);
    if (ajax_chain_select_valid_token($dch, $dc2) && function_exists($dc2)) {
      $data_callback = $dc2;
      $data = $data_callback($level, $previous_level_key);
    }
  }

  if (!empty($data)) {
    $has_data = 1;
    foreach ($data as $key => $value) {
      $options .= '<option value="' . $key . '">' . $value . '</option>';
    }
  }
  drupal_json_output(array('has_data' => $has_data, 'options' => $options));
}

/**
 * Generates a token based on $value, and the private key.
 *
 * Note: This is similar to drupal_get_token but without using session_id.
 *
 * @param string $value
 *   An additional value to base the token on.
 *
 * @return string
 *   A 43-character URL-safe token for validation.
 */
function ajax_chain_select_get_token($value = '') {
  return drupal_hmac_base64($value, drupal_get_private_key() . drupal_get_hash_salt());
}

/**
 * Validates a token based on $value and the private key.
 *
 * Note: This is similar to drupal_valid_token but without using session_id.
 *
 * @param string $token
 *   The token to be validated.
 * @param string $value
 *   An additional value to base the token on.
 *
 * @return bool
 *   True for a valid token, false for an invalid token.
 */
function ajax_chain_select_valid_token($token, $value = '') {
  return ($token === ajax_chain_select_get_token($value));
}
